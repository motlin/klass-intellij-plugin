{
  parserClass="com.klass.intellij.parser.KlassParser"
  parserUtilClass="com.klass.intellij.parser.KlassParserUtil"
  psiPackage="com.klass.intellij.psi"
  psiImplPackage="com.klass.intellij.psi.impl"

  elementTypeHolderClass="com.klass.intellij.psi.KlassTypes"
  elementTypeClass="com.klass.intellij.psi.KlassElementType"
  psiClassPrefix="Klass"
  psiImplClassSuffix="Impl"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiImplUtilClass="com.klass.intellij.psi.impl.KlassPsiImplUtil"
  tokenTypeClass="com.klass.intellij.psi.KlassTokenType"

  tokens = [
    LBRACE='{'
    RBRACE='}'
    LBRACKET='['
    RBRACKET=']'
    LPAREN='('
    RPAREN=')'
    COLON=':'
    DOT='.'
    DOTDOT='..'
    SLASH='/'
    TICK='`'
    COMMA=','
    ANDAND='&&'
    OROR='||'
    EQEQ='=='
    NE='!='
    LT='<'
    GT='>'
    LE='<='
    GE='>='
    PLUS='+'
    MINUS='-'
    PERCENT='%'
    EXCL='!'
    QUESTION_MARK='?'
    EQ='='
    AND='&'
    SEMICOLON=';'
    IN_OPERATOR='in'
    CONTAINS_OPERATOR='contains'
    STARTS_WITH_OPERATOR='startsWith'
    ENDS_WITH_OPERATOR='endsWith'
    PACKAGE_KEYWORD='package'
    USER_KEYWORD='user'
    EXTENDS_KEYWORD='extends'
    IMPLEMENTS_KEYWORD='implements'
    KEY_MODIFIER='key'
    PRIVATE_MODIFIER='private'
    OWNED_MODIFIER='owned'
    FINAL_MODIFIER='final'
    ID_MODIFIER='id'
    USER_ID_MODIFIER='userId'
    VALID_MODIFIER='valid'
    SYSTEM_MODIFIER='system'
    FROM_MODIFIER='from'
    TO_MODIFIER='to'
    CREATED_BY_MODIFIER='createdBy'
    CREATED_ON_MODIFIER='createdOn'
    LAST_UPDATED_BY_MODIFIER='lastUpdatedBy'
    ON_KEYWORD='on'
    RELATIONSHIP_KEYWORD='relationship'
    GET_VERB='GET'
    POST_VERB='POST'
    PUT_VERB='PUT'
    PATCH_VERB='PATCH'
    DELETE_VERB='DELETE'
    CRITERIA_KEYWORD='criteria'
    VALIDATE_KEYWORD='validate'
    CONFLICT_KEYWORD='conflict'
    AUTHORIZE_KEYWORD='authorize'
    NATIVE_KEYWORD='native'
    MULTIPLICITY_KEYWORD='multiplicity'
    ORDER_BY_KEYWORD='orderBy'
    ASCENDING_KEYWORD='ascending'
    DESCENDING_KEYWORD='descending'
    ONE_KEYWORD='one'
    MANY_KEYWORD='many'
    THIS_KEYWORD='this'
    ALL_KEYWORD='all'
    EQUALS_EDGEPOINT_KEYWORD='equalsEdgePoint'

    TRUE_KEYWORD='true'
    FALSE_KEYWORD='false'
    NULL_KEYWORD='null'
  ]

  mixin("projection")="com.klass.intellij.psi.impl.AbstractKlassProjectionNode"
  implements("projection")="com.klass.intellij.psi.KlassTypedElement"
  implements("expressionMemberName")="com.klass.intellij.psi.AbstractKlassExpressionMemberName"

  extends("expressionThisMember|expressionTypeMember")=expressionMemberName
  extends("criteriaGroup|criteriaAll|criteriaOperator|criteriaEdgePoint|criteriaNative")=atomicCriteria
  extends("expressionLiteral|expressionLiteralList|expressionMemberName|expressionNativeValue|expressionVariableName")=expressionValue
}

compilationUnit ::= package topLevelItem*

package ::= PACKAGE_KEYWORD fullyQualifiedPackageName
fullyQualifiedPackageName ::= packagePart ('.' packagePart)*
packagePart ::= nombre

topLevelItem ::= interface | klass | association | enumeration | projection | serviceGroup {recoverWhile="topLevelItem_recover"}
// TODO: Recovery rule isn't working
private topLevelItem_recover ::= !(rBrace | INTERFACE_KEYWORD | CLASS_KEYWORD | USER_KEYWORD | ASSOCIATION_KEYWORD | ENUMERATION_KEYWORD | PROJECTION_KEYWORD | SERVICE_KEYWORD)

fake classifier ::= nombre implementsClause? classModifier
{
    extends=topLevelItem
    mixin="com.klass.intellij.psi.impl.KlassNamedElementImpl"
}

interface ::= INTERFACE_KEYWORD nombre implementsClause? classModifier* interfaceBlock
{
    pin="{" methods=[setName getPresentation]
    extends=classifier
    implements="com.klass.intellij.psi.KlassNamedElement"
}
interfaceBlock ::= lBrace interfaceBody rBrace
interfaceBody ::= member*

klass ::= (CLASS_KEYWORD | USER_KEYWORD) nombre abstractClause? extendsClause? implementsClause? serviceProjection* classModifier* classBlock
{
    pin="{" methods=[setName getPresentation]
    extends=classifier
    implements="com.klass.intellij.psi.KlassNamedElement"
}
classBlock ::= lBrace classBody rBrace
classBody ::= member*

abstractClause ::= ABSTRACT_KEYWORD inheritanceParens?
inheritanceParens ::= '(' inheritanceType ')'
inheritanceType ::= TABLE_PER_SUBCLASS_KEYWORD | TABLE_FOR_ALL_KEYWORD | TABLE_PER_CLASS_KEYWORD
extendsClause ::= EXTENDS_KEYWORD klassName
implementsClause ::= IMPLEMENTS_KEYWORD implementsList
implementsList ::= interfaceName (',' interfaceName)*

association ::= ASSOCIATION_KEYWORD nombre associationBlock
{
    pin="{" methods=[setName getPresentation]
    extends=topLevelItem
    implements="com.klass.intellij.psi.KlassNamedElement"
    mixin="com.klass.intellij.psi.impl.KlassNamedElementImpl"
}
associationBlock ::= lBrace associationBody rBrace
associationBody ::= associationEnd* relationship?

enumeration ::= ENUMERATION_KEYWORD nombre enumerationBlock
{
    pin="{" methods=[setName getPresentation]
    extends=topLevelItem
    implements="com.klass.intellij.psi.KlassNamedElement"
    mixin="com.klass.intellij.psi.impl.KlassNamedElementImpl"
}
enumerationBlock ::= lBrace enumerationBody rBrace
enumerationBody ::= (enumerationLiteral COMMA)*

projection ::= PROJECTION_KEYWORD nombre parameterDeclarationsParens? 'on' klassName projectionBlock
{
    pin="{" methods=[setName getPresentation]
    extends=topLevelItem
    implements="com.klass.intellij.psi.KlassNamedElement"
    mixin="com.klass.intellij.psi.impl.AbstractKlassProjectionNode"
}
parameterDeclarationsParens ::= '(' parameterDeclarations ')'
parameterDeclarations ::= parameterDeclaration (',' parameterDeclaration)*
projectionBlock ::= lBrace projectionBody rBrace
projectionBody ::= (projectionNode ',')*

// TODO: Consider moving serviceGroup inside class
serviceGroup ::= SERVICE_KEYWORD klassName serviceGroupBlock
{
    pin="{" methods=[getPresentation]
    extends=topLevelItem
}
serviceGroupBlock ::= lBrace serviceGroupBody rBrace
serviceGroupBody ::= urlGroup*

projectionNode ::=  projectionLeafNode | projectionParameterizedPropertyNode | projectionAssociationEndNode | projectionProjectionNode
// TODO: This only allows passing scoped variables, but expressions (literals) should work here
projectionLeafNode ::= (classifierName '.')? memberName ':' header
{
    extends=projectionNode
}
projectionParameterizedPropertyNode ::= (classifierName '.')? parameterizedPropertyName parameterNamesParens ':' projectionBlock
{
    extends=projectionNode
}
parameterNamesParens ::= '(' parameterNames? ')'
parameterNames ::= parameterName (',' parameterName)*
fake projectionWithAssociationEnd ::= (classifierName '.')? associationEndName
{
    extends=projectionNode
    implements="com.klass.intellij.psi.KlassTypedElement"
}
projectionAssociationEndNode ::= (classifierName '.')? associationEndName ':' projectionBlock
{
    extends=projectionWithAssociationEnd
}
projectionProjectionNode ::= (classifierName '.')? associationEndName ':' projectionName
{
    extends=projectionWithAssociationEnd
}
header ::= STRING_LITERAL

urlGroup ::= url service+ {methods=[getPresentation]}
url ::= urlPart+ '/'? queryParams?
queryParams ::= '?' queryParamPart ('&' queryParamPart)*
urlPart ::= ('/' urlConstant) | ('/' lBrace parameterDeclaration rBrace) {pin='/'}
urlConstant ::= nombre
queryParamPart ::= lBrace parameterDeclaration rBrace

service ::= verb serviceBlock {pin=1 methods=[getPresentation]}
serviceBlock ::= lBrace serviceBody rBrace
serviceBody ::= serviceMultiplicityClause? serviceCriteriaClause? serviceAuthorizeClause? serviceValidateClause? serviceConflictClause? serviceProjectionClause? serviceOrderByClause?

// TODO: This order of criteria may not match antlr
serviceMultiplicityClause ::= MULTIPLICITY_KEYWORD ':' serviceMultiplicity SEMICOLON
serviceCriteriaClause ::= CRITERIA_KEYWORD ':' criteriaExpression SEMICOLON
serviceAuthorizeClause ::= AUTHORIZE_KEYWORD ':' criteriaExpression SEMICOLON
serviceValidateClause ::= VALIDATE_KEYWORD ':' criteriaExpression SEMICOLON
serviceConflictClause ::= CONFLICT_KEYWORD ':' criteriaExpression SEMICOLON
// TODO: This only allows passing scoped variables, but expressions (literals) should work here
serviceProjectionClause ::= PROJECTION_KEYWORD ':' projectionName ('(' parameterNames ')')? SEMICOLON
private serviceOrderByClause ::= orderByClause SEMICOLON

orderByClause ::= ORDER_BY_KEYWORD ':' (orderByProperty) (',' orderByProperty)*
orderByProperty ::= THIS_KEYWORD '.' memberName orderByDirection?
orderByDirection ::= ASCENDING_KEYWORD | DESCENDING_KEYWORD
serviceMultiplicity ::= 'one' | 'many'
verb ::= GET_VERB | POST_VERB | PUT_VERB | PATCH_VERB | DELETE_VERB

// Left recursion isn't well supported in Grammar-Kit
criteriaExpression ::= criteriaAnd
criteriaAnd ::= (criteriaOr '&&' criteriaAnd) | criteriaOr
criteriaOr ::= (atomicCriteria '||' criteriaOr) | atomicCriteria
atomicCriteria ::= criteriaGroup | criteriaAll | criteriaOperator | criteriaEdgePoint | criteriaNative

criteriaGroup ::= '(' criteriaExpression ')'
criteriaAll ::= ALL_KEYWORD;
// Overly generic, since clauses like 1 == 2 and 2 == $id don't make sense
criteriaOperator ::= sourceExpressionValue operator targetExpressionValue
criteriaEdgePoint ::= expressionMemberName EQUALS_EDGEPOINT_KEYWORD
criteriaNative ::= 'native' '(' nombre ')'
sourceExpressionValue ::= expressionValue
targetExpressionValue ::= expressionValue

expressionValue ::= expressionLiteral | expressionLiteralsParens | expressionThisMember | expressionTypeMember | expressionNativeValue | expressionVariableName
expressionLiteral ::= integerLiteralNode | floatLiteralNode | stringLiteralNode | booleanLiteral
expressionLiteralsParens ::= '(' expressionLiterals ')'
expressionLiterals ::= expressionLiteral (',' expressionLiteral)*

expressionMemberName ::= expressionThisMember | expressionTypeMember
expressionThisMember ::= THIS_KEYWORD '.' (associationEndName '.')* memberName
expressionTypeMember ::= klassName '.' (associationEndName '.')* memberName

operator ::= EQEQ | NE | LT | GT | LE | GE | 'in' | CONTAINS_OPERATOR | STARTS_WITH_OPERATOR | ENDS_WITH_OPERATOR

relationship ::= RELATIONSHIP_KEYWORD criteriaExpression

fake nombred ::= nombre
{
    mixin="com.klass.intellij.psi.impl.KlassNamedElementImpl"
}

member ::= dataTypeProperty | parameterizedProperty | parameterizedPropertySignature | associationEndSignature
{
    extends=nombred
    implements="com.klass.intellij.psi.KlassNamedElement"
}

dataTypeProperty ::= primitiveTypeProperty | enumerationProperty
{
    extends=member
}

primitiveTypeProperty ::= nombre ':' primitiveType optionalMarker? propertyModifier* dataTypePropertyValidation* SEMICOLON
{
    methods=[setName getPresentation]
    extends=dataTypeProperty
}

enumerationProperty ::= nombre ':' enumerationType optionalMarker? propertyModifier* dataTypePropertyValidation* SEMICOLON
{
    methods=[setName getPresentation]
    extends=dataTypeProperty
}

parameterizedProperty ::= nombre propertyParameterDeclarationsParens ':' klassName multiplicity parameterizedPropertyModifier* orderByClause? lBrace criteriaExpression rBrace
{
    methods=[setName getPresentation]
    extends=member
}

parameterizedPropertySignature ::= nombre propertyParameterDeclarationsParens ':' classifierName multiplicity parameterizedPropertyModifier* ';'
{
    methods=[setName getPresentation]
    extends=member
}

propertyParameterDeclarationsParens ::= '(' parameterDeclarations? ')'

classModifier ::= SYSTEM_TEMPORAL_MODIFIER | VALID_TEMPORAL_MODIFIER | BITEMPORAL_MODIFIER  | VERSIONED_MODIFIER | AUDITED_MODIFIER | OPTIMISTICALLY_LOCKED_MODIFIER | TRANSIENT_MODIFIER
propertyModifier ::= KEY_MODIFIER | PRIVATE_MODIFIER | ID_MODIFIER | USER_ID_MODIFIER | VALID_MODIFIER | SYSTEM_MODIFIER | FROM_MODIFIER | TO_MODIFIER | CREATED_BY_MODIFIER | CREATED_ON_MODIFIER | LAST_UPDATED_BY_MODIFIER | VERSION_MODIFIER | DERIVED_MODIFIER
parameterizedPropertyModifier ::= CREATED_BY_MODIFIER | LAST_UPDATED_BY_MODIFIER
associationEndModifier ::= OWNED_MODIFIER | FINAL_MODIFIER | VERSION_MODIFIER
parameterModifier ::= VERSION_MODIFIER  | ID_MODIFIER | USER_ID_MODIFIER

dataTypePropertyValidation ::= minLengthValidation | maxLengthValidation | minValidation | maxValidation

minLengthValidation ::= (MIN_LENGTH_KEYWORD | MINIMUM_LENGTH_KEYWORD) integerParens
maxLengthValidation ::= (MAX_LENGTH_KEYWORD | MAXIMUM_LENGTH_KEYWORD) integerParens
minValidation ::= (MIN_KEYWORD | MINIMUM_KEYWORD) integerParens
maxValidation ::= (MAX_KEYWORD | MAXIMUM_KEYWORD) integerParens
integerParens ::= '(' INTEGER_LITERAL ')'

serviceProjection ::= serviceCategory (projectNameParens)?
projectNameParens ::= '(' projectionName ')'
serviceCategory ::= READ_KEYWORD | WRITE_KEYWORD | CREATE_KEYWORD | UPDATE_KEYWORD | DELETE_KEYWORD

// TODO: packages, imports, fully qualified class names
// TODO: split property keywords and association end keywords
associationEnd ::= nombre ':' klassName multiplicity associationEndModifier* orderByClause? SEMICOLON
{
    methods=[setName getPresentation]
    extends=nombred
    implements="com.klass.intellij.psi.KlassNamedElement"
}

associationEndSignature ::= nombre ':' classifierName multiplicity associationEndModifier* ';'
{
    methods=[setName getPresentation]
    extends=member
}

lBrace ::= '{'
rBrace ::= '}'

// Just can't be called name, because the getName method would clash
nombre ::= nombreText // TODO: Inline
nombreText ::= IDENTIFIER | PACKAGE_KEYWORD | INTERFACE_KEYWORD | CLASS_KEYWORD | ASSOCIATION_KEYWORD | ENUMERATION_KEYWORD | PROJECTION_KEYWORD | SERVICE_KEYWORD | USER_KEYWORD | KEY_MODIFIER | PRIVATE_MODIFIER | OWNED_MODIFIER | FINAL_MODIFIER | ABSTRACT_KEYWORD | SYSTEM_TEMPORAL_MODIFIER | VALID_TEMPORAL_MODIFIER | BITEMPORAL_MODIFIER  | VERSIONED_MODIFIER | AUDITED_MODIFIER | OPTIMISTICALLY_LOCKED_MODIFIER | TRANSIENT_MODIFIER | VERSION_MODIFIER | DERIVED_MODIFIER | USER_ID_MODIFIER | ID_MODIFIER | VALID_MODIFIER | SYSTEM_MODIFIER | FROM_MODIFIER | TO_MODIFIER | CREATED_BY_MODIFIER | CREATED_ON_MODIFIER | LAST_UPDATED_BY_MODIFIER | BOOLEAN_KEYWORD | INTEGER_KEYWORD | LONG_KEYWORD | DOUBLE_KEYWORD | FLOAT_KEYWORD | STRING_KEYWORD | INSTANT_KEYWORD | LOCAL_DATE_KEYWORD | TEMPORAL_INSTANT_KEYWORD | TEMPORAL_RANGE_KEYWORD | READ_KEYWORD | WRITE_KEYWORD | CREATE_KEYWORD | UPDATE_KEYWORD | DELETE_KEYWORD | MULTIPLICITY_KEYWORD | ORDER_BY_KEYWORD | CONTAINS_OPERATOR | STARTS_WITH_OPERATOR | ENDS_WITH_OPERATOR | IN_OPERATOR | ALL_KEYWORD | EQUALS_EDGEPOINT_KEYWORD | CRITERIA_KEYWORD | GET_VERB | POST_VERB | PUT_VERB | PATCH_VERB | DELETE_VERB

enumerationLiteral ::= nombre ('(' enumerationPrettyName ')')?
{
    methods=[setName getPresentation]
    extends=nombred
    implements="com.klass.intellij.psi.KlassNamedElement"
}

parameterDeclaration ::= nombre (':' dataTypeDeclaration)? parameterModifier*
{
    methods=[setName]
    extends=nombred
    implements="com.klass.intellij.psi.KlassNamedElement"
}

dataType ::= primitiveType | enumerationType;
primitiveType ::= BOOLEAN_KEYWORD | INTEGER_KEYWORD | LONG_KEYWORD | DOUBLE_KEYWORD | FLOAT_KEYWORD | STRING_KEYWORD | INSTANT_KEYWORD | LOCAL_DATE_KEYWORD | TEMPORAL_INSTANT_KEYWORD | TEMPORAL_RANGE_KEYWORD
{
    methods=[getReference]
    extends=dataType
}
enumerationType ::= nombre
{
    methods=[getReference]
    extends=dataType
}

dataTypeDeclaration ::= dataType multiplicity
enumerationPrettyName ::= STRING_LITERAL
optionalMarker ::= QUESTION_MARK

interfaceName ::= nombre {methods=[getReference]}
classifierName ::= nombre {methods=[getReference]}
klassName ::= nombre {methods=[getReference]}
memberName ::= nombre {methods=[getReference]}
associationEndName ::= nombre {methods=[getReference]}
parameterizedPropertyName ::= nombre {methods=[getReference]}
projectionName ::= nombre {methods=[getReference]}
expressionVariableName ::= nombre {methods=[getReference]}
parameterName ::= nombre {methods=[getReference]}

expressionNativeValue ::= USER_KEYWORD {methods=[getReference]}

multiplicity ::= '[' ((lowerBound '..' upperBound) | dummyMultiplicity) ']'
dummyMultiplicity ::= lowerBound | lowerBound '..' {methods=[getReference]}

lowerBound ::= INTEGER_LITERAL
upperBound ::= INTEGER_LITERAL | ASTERISK
booleanLiteral ::= TRUE_KEYWORD | FALSE_KEYWORD | NULL_KEYWORD
integerLiteralNode ::= INTEGER_LITERAL
floatLiteralNode ::= FLOAT_LITERAL
stringLiteralNode ::= STRING_LITERAL
