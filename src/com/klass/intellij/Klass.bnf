{
  parserClass="com.klass.intellij.parser.KlassParser"
  parserUtilClass="com.klass.intellij.parser.KlassParserUtil"
  psiPackage="com.klass.intellij.psi"
  psiImplPackage="com.klass.intellij.psi.impl"

  elementTypeHolderClass="com.klass.intellij.psi.KlassTypes"
  elementTypeClass="com.klass.intellij.psi.KlassElementType"
  psiClassPrefix="Klass"
  psiImplClassSuffix="Impl"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiImplUtilClass="com.klass.intellij.psi.impl.KlassPsiImplUtil"
  tokenTypeClass="com.klass.intellij.psi.KlassTokenType"

  mixin("klass|association|enumeration|dataTypeProperty|enumerationProperty|parameterizedProperty|associationEnd|pathParameter|parameterDeclaration") = "com.klass.intellij.psi.impl.KlassNamedElementImpl"
  mixin("projection")="com.klass.intellij.psi.impl.AbstractKlassProjectionNode"
  mixin("projectionInnerNode")="com.klass.intellij.psi.impl.AbstractKlassInnerProjectionNode"
  implements("klass|association|enumeration|projection|member|dataTypeProperty|enumerationProperty|parameterizedProperty|associationEnd|pathParameter|parameterDeclaration") = "com.klass.intellij.psi.KlassNamedElement"
  implements("projection|projectionInnerNode")="com.klass.intellij.psi.KlassTypedElement"

  tokens = [
    LBRACE='{'
    RBRACE='}'
    LBRACKET='['
    RBRACKET=']'
    LPAREN='('
    RPAREN=')'
    COLON=':'
    DOT='.'
    DOTDOT='..'
    SLASH='/'
    TICK='`'
    COMMA=','
    ANDAND='&&'
    OROR='||'
    EQEQ='=='
    NE='!='
    LT='<'
    GT='>'
    LE='<='
    GE='>='
    PLUS='+'
    MINUS='-'
    PERCENT='%'
    EXCL='!'
    CONTAINS_OPERATOR='contains'
    STARTS_WITH_OPERATOR='startsWith'
    ENDS_WITH_OPERATOR='endsWith'
    CLASS_KEYWORD='class'
    ASSOCIATION_KEYWORD='association'
    ENUMERATION_KEYWORD='enumeration'
    PROJECTION_KEYWORD='projection'
    SERVICE_KEYWORD='service'
    USER_KEYWORD='user'
    KEY_KEYWORD='key'
    ON_KEYWORD='on'
    GET_VERB='GET'
    POST_VERB='POST'
    PUT_VERB='PUT'
    PATCH_VERB='PATCH'
    DELETE_VERB='DELETE'
    CRITERIA_KEYWORD='criteria'
    MULTIPLICITY_KEYWORD='multiplicity'
    ORDER_BY_KEYWORD='orderBy'
    ASCENDING_KEYWORD='ascending'
    DESCENDING_KEYWORD='descending'
    ONE_KEYWORD='one'
    MANY_KEYWORD='many'
    THIS_KEYWORD='this'

    TRUE_KEYWORD='true'
    FALSE_KEYWORD='false'
    NULL_KEYWORD='null'
  ]

  extends("klass|association|enumeration|projection|serviceGroup")=topLevelItem
  extends("dataTypeProperty|enumerationProperty|parameterizedProperty")=member
  extends("projectionInnerNode|projectionLeafNode")=projectionNode
  extends("criteriaAnd|criteriaOr|criteriaOperator")=criteriaExpression
}

compilationUnit ::= topLevelItem*

topLevelItem ::= klass | association | enumeration | projection | serviceGroup {recoverWhile="topLevelItem_recover"}
private topLevelItem_recover ::= !('}' | 'class' | 'association' | 'enumeration' | 'projection' | 'service' | 'user')

klass ::= ('class' | 'user') nombre readProjection? writeProjection? keywordOnClass* lBrace member* rBrace {pin="{" methods=[setName getPresentation]}
association ::= 'association' nombre '{' associationEnd* '}' {pin="{" methods=[setName getPresentation]}
enumeration ::= 'enumeration' nombre lBrace (enumerationLiteral COMMA)* rBrace {pin="{" methods=[setName getPresentation]}
projection ::= 'projection' nombre ('(' parameterDeclaration (',' parameterDeclaration)* ')')? 'on' klassName lBrace (projectionNode ',')* rBrace {pin="{" methods=[setName getPresentation]}
serviceGroup ::= 'service' klassName lBrace urlGroup* rBrace {pin="{" methods=[getPresentation]}

projectionNode ::= projectionInnerNode | projectionLeafNode
projectionInnerNode ::= ((parameterizedPropertyName '(' parameterName (',' parameterName)* ')') | associationEndName) ':' '{' (projectionNode ',')* '}'
projectionLeafNode ::= propertyName ':'? header?
header ::= STRING_LITERAL

urlGroup ::= url service+ {methods=[getPresentation]}
url ::= urlPart+ '/'?
urlPart ::= ('/' urlConstant) | ('/' '{' pathParameter '}') {pin='/'}
urlConstant ::= nombre
pathParameter ::= nombre {methods=[setName]}
service ::= verb lBrace serviceMultiplicityClause serviceCriteriaClause? serviceProjectionClause orderByClause? rBrace {pin=1 methods=[getPresentation]}

serviceMultiplicityClause ::= 'multiplicity' ':' serviceMultiplicity
serviceCriteriaClause ::= 'criteria' ':' criteriaExpression
serviceProjectionClause ::= 'projection' ':' projectionName ('(' parameterName (',' parameterName)* ')')?
orderByClause ::= 'orderBy' ':' (orderByProperty) (',' orderByProperty)*
orderByProperty ::= 'this' '.' propertyName orderByDirection?
orderByDirection ::= 'ascending' | 'descending'
serviceMultiplicity ::= 'one' | 'many'
verb ::= 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE'

criteriaExpression ::= criteriaAnd | criteriaOr | criteriaOperator
criteriaAnd ::= criteriaExpression '&&' criteriaExpression
criteriaOr ::= criteriaExpression '||' criteriaExpression
// Overly generic, since clauses like 1 == 2 and 2 == $id don't make sense
criteriaOperator ::= sourceExpressionValue operator targetExpressionValue
sourceExpressionValue ::= expressionValue
targetExpressionValue ::= expressionValue
expressionValue ::= expressionLiteral | expressionProperty | expressionVariableName
expressionLiteral ::= INTEGER_LITERAL | FLOAT_LITERAL | STRING_LITERAL | booleanLiteral
expressionProperty ::= criteriaType '.' propertyName
criteriaType ::= 'this' | klassName
operator ::= EQEQ | NE | LT | GT | LE | GE | 'contains' | 'startsWith' | 'endsWith'

member ::= dataTypeProperty | enumerationProperty | parameterizedProperty
dataTypeProperty ::= propertyKeyword* nombre ':' dataType optionalMarker? {methods=[setName getPresentation]}
enumerationProperty ::= propertyKeyword* nombre ':' enumerationType optionalMarker? {methods=[setName getPresentation]}
parameterizedProperty ::= nombre '(' (parameterDeclaration (',' parameterDeclaration)*)? ')' ':' klassName multiplicity orderByClause? lBrace criteriaExpression rBrace {methods=[setName getPresentation]}

keywordOnClass ::= SYSTEM_TEMPORAL_KEYWORD | VALID_TEMPORAL_KEYWORD | BITEMPORAL_KEYWORD  | VERSIONED_KEYWORD | AUDITED_KEYWORD | OPTIMISTICALLY_LOCKED_KEYWORD
readProjection ::= READ_KEYWORD ('(' projectionName ')')?
writeProjection ::= WRITE_KEYWORD ('(' projectionName ')')?
propertyKeyword ::= 'key'

// TODO: packages, imports, fully qualified class names
associationEnd ::= nombre ':' klassName? multiplicity? orderByClause? {methods=[setName getPresentation]}

lBrace ::= '{'
rBrace ::= '}'

// Just can't be called name, because the getName method would clash
nombre ::= nombreText | '`' nombreText '`'
nombreText ::= IDENTIFIER | 'class' | 'association' | 'enumeration' | 'projection' | 'service' | 'user' | 'key' | SYSTEM_TEMPORAL_KEYWORD | VALID_TEMPORAL_KEYWORD | BITEMPORAL_KEYWORD | VERSIONED_KEYWORD | ID_KEYWORD | BOOLEAN_KEYWORD | INTEGER_KEYWORD | LONG_KEYWORD | DOUBLE_KEYWORD | FLOAT_KEYWORD | STRING_KEYWORD | INSTANT_KEYWORD | LOCAL_DATE_KEYWORD | READ_KEYWORD | WRITE_KEYWORD | OPTIMISTICALLY_LOCKED_KEYWORD
enumerationLiteral ::= nombre ('(' enumerationPrettyName ')')?

parameterDeclaration ::= nombre ':' (dataType | enumerationType) {methods=[setName]}
dataType ::= ID_KEYWORD | BOOLEAN_KEYWORD | INTEGER_KEYWORD | LONG_KEYWORD | DOUBLE_KEYWORD | FLOAT_KEYWORD | STRING_KEYWORD | INSTANT_KEYWORD | LOCAL_DATE_KEYWORD {methods=[getReference]}
enumerationType ::= nombre {methods=[getReference]}
enumerationPrettyName ::= STRING_LITERAL
klassName ::= nombre {methods=[getReference]}
propertyName ::= nombre {methods=[getReference]}
associationEndName ::= nombre {methods=[getReference]}
parameterizedPropertyName ::= nombre {methods=[getReference]}
projectionName ::= nombre {methods=[getReference]}
expressionVariableName ::= nombre {methods=[getReference]}
parameterName ::= nombre {methods=[getReference]}
optionalMarker ::= QUESTION_MARK

multiplicity ::= '[' ((lowerBound '..' upperBound) | dummyMultiplicity) ']'
dummyMultiplicity ::= lowerBound | lowerBound '..' {methods=[getReference]}

lowerBound ::= INTEGER_LITERAL
upperBound ::= INTEGER_LITERAL | ASTERISK
booleanLiteral ::= 'true' | 'false' | 'null'
